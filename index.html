<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Coin Predictions — Buy Coins & Generate Predictions</title>
<style>
  :root{
    --bg: #0b1220;
    --card: #0f1724;
    --accent: #00d2a8;
    --muted: #9fb0d6;
  }
  *{box-sizing:border-box;font-family:Inter,Arial,sans-serif}
  body{margin:0;background:linear-gradient(180deg,#071021,#0b1220);color:#eaf6ff;min-height:100vh;padding:18px}
  .wrap{max-width:980px;margin:20px auto}
  .card{background:rgba(255,255,255,0.03);padding:16px;border-radius:12px;margin-bottom:14px;border:1px solid rgba(255,255,255,0.02)}
  h1{margin:0 0 8px 0;font-size:20px}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .col{flex:1;min-width:240px}
  label{display:block;color:var(--muted);font-size:13px;margin-bottom:6px}
  input[type=number], input[type=text]{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  select{padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit}
  .btn{padding:10px 14px;border-radius:8px;border:none;background:linear-gradient(90deg,var(--accent),#00a6ff);color:#001;font-weight:800;cursor:pointer}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .small{font-size:13px;color:var(--muted)}
  .center{text-align:center}
  .qr{width:220px;height:220px;border-radius:12px;display:block;margin:10px auto;border:2px solid rgba(255,255,255,0.03)}
  .wallet{font-size:18px;font-weight:800}
  .note{color:#ffdca8;font-weight:700}
  .admin-cross{position:fixed;right:14px;bottom:14px;width:44px;height:44px;border-radius:10px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:9999}
  .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:2000;visibility:hidden;opacity:0;transition:all .15s}
  .modal.show{visibility:visible;opacity:1}
  .modal .card{min-width:320px;max-width:560px}
  .period{font-weight:800;font-size:14px}
  .stats{font-size:13px;color:var(--muted)}
  .history{max-height:160px;overflow:auto;padding:8px;border-radius:8px;background:rgba(0,0,0,0.25)}
</style>
</head>
<body>

<div class="wrap">
  <div class="card">
    <h1>Coin Predictions — Buy Coins & Generate</h1>
    <div class="small">Buy coins → admin approves payment (UTR) → coins credited → use 2 coins per prediction.</div>
  </div>

  <!-- Buy coins -->
  <div class="card row">
    <div class="col">
      <label>Choose coins (min 100 — max 4000)</label>
      <input id="coinsInput" type="number" min="100" max="4000" step="1" value="100">
      <div style="margin-top:8px" class="small">Pricing: <b>100 coins = ₹50</b> (so ₹0.5 per coin). You can buy any amount between 100 and 4000.</div>
      <div style="margin-top:12px" class="row">
        <button id="buyBtn" class="btn">Buy Coins</button>
        <button id="preset100" class="ghost">100</button>
        <button id="preset500" class="ghost">500</button>
        <button id="preset1000" class="ghost">1000</button>
      </div>
    </div>

    <div class="col center">
      <div class="small">QR for payment (scan with UPI)</div>
      <img id="qrImage" class="qr" src="qr.png" alt="QR — replace qr.png">
      <div class="small" style="margin-top:8px">After payment, enter 12-digit UTR and confirm. Admin will verify & approve.</div>
    </div>

    <div class="col">
      <label>Your Wallet</label>
      <div class="wallet" id="walletCoins">Coins: 0</div>
      <div style="margin-top:8px" class="small">Use <b>2 coins</b> to generate one prediction.</div>
      <div style="margin-top:12px" class="small">Pending purchases:</div>
      <div id="pendingList" class="history"></div>
    </div>
  </div>

  <!-- Payment modal -->
  <div id="payModal" class="modal">
    <div class="card">
      <h2 style="margin-top:0">Confirm Payment</h2>
      <div class="small">QR shown on page above. After paying, enter 12-digit UTR and press Submit.</div>
      <div style="margin-top:10px">
        <label>Coins to buy</label>
        <input id="modalCoins" type="number" readonly>
        <label style="margin-top:8px">Amount (₹)</label>
        <input id="modalAmount" type="text" readonly>
        <label style="margin-top:8px">Enter 12-digit UTR</label>
        <input id="modalUTR" type="text" maxlength="12" placeholder="Enter UTR">
        <div style="margin-top:10px" class="row">
          <button id="modalSubmit" class="btn">Submit Purchase</button>
          <button id="modalClose" class="ghost">Cancel</button>
        </div>
        <div id="modalMsg" class="small" style="margin-top:8px"></div>
        <div class="note" id="csNote" style="display:none;margin-top:8px">Payment complete but not open — contact: <a href="https://t.me/Nskskssiwi" target="_blank" style="color:#bfe">Customer Service</a></div>
      </div>
    </div>
  </div>

  <!-- Prediction area -->
  <div class="card">
    <div class="row">
      <div class="col">
        <label>Live period (auto-updates every minute)</label>
        <div class="period" id="periodDisplay">--</div>
        <div class="small" id="countdown">Next period in: --s</div>

        <div style="margin-top:12px">
          <label>Enter last 3 digits of period (optional for record)</label>
          <input id="period3" type="text" maxlength="3" placeholder="e.g. 123">
        </div>

        <div style="margin-top:12px" class="row">
          <button id="generateBtn" class="btn">Generate Prediction (2 coins)</button>
          <button id="refreshWallet" class="ghost">Refresh Wallet</button>
        </div>

        <div style="margin-top:12px">
          <div id="predictionArea" class="card" style="padding:12px;display:none">
            <div><b>Period:</b> <span id="predPeriod">--</span></div>
            <div style="margin-top:6px"><b>Signal:</b> <span id="predSignal">--</span></div>
            <div style="margin-top:6px"><b>Numbers:</b> <span id="predNums">-- / --</span></div>
            <div style="margin-top:8px" class="small">History (latest first):</div>
            <div id="predHistory" class="history"></div>
          </div>
        </div>
      </div>

      <div class="col">
        <label>Stats</label>
        <div class="small">Last results:</div>
        <div id="resultsArea" class="history"></div>

        <div style="margin-top:12px">
          <label>Admin actions (hidden — open with ❌ at bottom-right)</label>
          <div class="small">Admin can approve/reject purchases.</div>
          <div id="adminStatus" class="small" style="margin-top:8px"></div>
        </div>
      </div>
    </div>
  </div>

</div>

<!-- admin cross (hidden toggle) -->
<div class="admin-cross" id="adminCross">❌</div>

<!-- admin modal -->
<div id="adminModal" class="modal">
  <div class="card">
    <h2 style="margin-top:0">Admin — Approve Purchases</h2>
    <div class="small">Pending purchases below. Click Approve to credit wallet.</div>
    <div id="adminPending" class="history" style="margin-top:10px"></div>
    <div style="margin-top:12px" class="row">
      <button id="adminClose" class="ghost">Close</button>
    </div>
    <div id="adminMsg" class="small" style="margin-top:8px"></div>
  </div>
</div>

<script>
/*
  coin-prediction.html
  - Save as a single file.
  - Put your QR image as qr.png (same folder).
  - Admin password: Mrperfect456
  - Storage:
      pending_<utr> => JSON purchase object { utr, coins, amount, ts, status }
      approved_<utr> => JSON approved info
      wallet_coins => integer (user's coin balance)
      predictions => array of last predictions
*/

const ADMIN_PASS = 'Mrperfect456';
const MIN_COINS = 100;
const MAX_COINS = 4000;
const PRICE_PER_COIN = 0.5; // ₹0.5 per coin
const PRED_COST = 2; // 2 coins per prediction

// DOM
const coinsInput = document.getElementById('coinsInput');
const buyBtn = document.getElementById('buyBtn');
const preset100 = document.getElementById('preset100');
const preset500 = document.getElementById('preset500');
const preset1000 = document.getElementById('preset1000');
const qrImage = document.getElementById('qrImage');
const walletCoinsEl = document.getElementById('walletCoins');
const pendingListEl = document.getElementById('pendingList');

const payModal = document.getElementById('payModal');
const modalCoins = document.getElementById('modalCoins');
const modalAmount = document.getElementById('modalAmount');
const modalUTR = document.getElementById('modalUTR');
const modalSubmit = document.getElementById('modalSubmit');
const modalClose = document.getElementById('modalClose');
const modalMsg = document.getElementById('modalMsg');
const csNote = document.getElementById('csNote');

const periodDisplay = document.getElementById('periodDisplay');
const countdownEl = document.getElementById('countdown');
const generateBtn = document.getElementById('generateBtn');
const predictionArea = document.getElementById('predictionArea');
const predPeriod = document.getElementById('predPeriod');
const predSignal = document.getElementById('predSignal');
const predNums = document.getElementById('predNums');
const predHistory = document.getElementById('predHistory');

const resultsArea = document.getElementById('resultsArea');
const adminCross = document.getElementById('adminCross');
const adminModal = document.getElementById('adminModal');
const adminPending = document.getElementById('adminPending');
const adminClose = document.getElementById('adminClose');
const adminMsg = document.getElementById('adminMsg');
const refreshWalletBtn = document.getElementById('refreshWallet');
const period3 = document.getElementById('period3');

// util storage functions
function readJSON(key, fallback = null){
  try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; } catch(e){ return fallback; }
}
function writeJSON(key,obj){ localStorage.setItem(key, JSON.stringify(obj)); }

// wallet
function getWallet(){ return parseInt(localStorage.getItem('wallet_coins')||'0',10); }
function setWallet(n){ localStorage.setItem('wallet_coins', String(n)); updateWalletUI(); }
function updateWalletUI(){ walletCoinsEl.innerText = 'Coins: ' + getWallet(); }

// pending purchases UI
function renderPendingList(){
  const items = [];
  for(let i=0;i<localStorage.length;i++){
    const k = localStorage.key(i);
    if(k && k.startsWith('pending_')){
      const v = readJSON(k);
      if(v) items.push({key:k, val:v});
    }
  }
  pendingListEl.innerHTML = '';
  if(items.length===0){ pendingListEl.innerHTML = '<div class="small">No pending purchases</div>'; return; }
  items.sort((a,b)=>b.val.ts - a.val.ts);
  items.forEach(it=>{
    const d = it.val;
    const div = document.createElement('div');
    div.style.padding = '8px';
    div.style.borderBottom='1px solid rgba(255,255,255,0.03)';
    div.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div><b>${d.coins} coins</b> — ₹${(d.amount).toFixed(2)}</div>
        <div class="small">UTR: ${d.utr} • ${new Date(d.ts).toLocaleString()}</div>
      </div>
      <div style="text-align:right"><div class="small">${d.status||'pending'}</div></div>
    </div>`;
    pendingListEl.appendChild(div);
  });
}

// admin pending list in admin modal
function renderAdminPending(){
  adminPending.innerHTML = '';
  const items = [];
  for(let i=0;i<localStorage.length;i++){
    const k = localStorage.key(i);
    if(k && k.startsWith('pending_')){
      const v = readJSON(k);
      if(v) items.push({key:k, val:v});
    }
  }
  if(items.length===0){ adminPending.innerHTML = '<div class="small">No pending purchases</div>'; return; }
  items.sort((a,b)=>b.val.ts - a.val.ts);
  items.forEach(it=>{
    const d = it.val;
    const row = document.createElement('div');
    row.style.padding='8px';
    row.style.borderBottom='1px solid rgba(255,255,255,0.03)';
    row.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div><b>${d.coins} coins</b> — ₹${(d.amount).toFixed(2)}</div>
        <div class="small">UTR: ${d.utr} • ${new Date(d.ts).toLocaleString()}</div>
      </div>
      <div style="text-align:right">
        <button data-utr="${d.utr}" class="btn admin-approve">Approve</button>
        <button data-utr="${d.utr}" class="ghost admin-reject" style="margin-left:6px">Reject</button>
      </div>
    </div>`;
    adminPending.appendChild(row);
  });

  // attach handlers
  Array.from(document.getElementsByClassName('admin-approve')).forEach(btn=>{
    btn.onclick = ()=>{ const utr = btn.getAttribute('data-utr'); adminApprove(utr); };
  });
  Array.from(document.getElementsByClassName('admin-reject')).forEach(btn=>{
    btn.onclick = ()=>{ const utr = btn.getAttribute('data-utr'); adminReject(utr); };
  });
}

// admin actions
function adminApprove(utr){
  const key = 'pending_' + utr;
  const data = readJSON(key);
  if(!data){ adminMsg.innerText = 'Pending not found'; return; }
  // credit wallet for the user who created (we don't have multi-user identification here)
  // Add the coins to wallet_coins
  const current = getWallet();
  setWallet(current + Number(data.coins));
  // mark approved
  writeJSON('approved_' + utr, {utr, coins: data.coins, amount: data.amount, ts: Date.now()});
  // remove pending
  localStorage.removeItem(key);
  adminMsg.innerText = 'Approved UTR ' + utr + ' — wallet credited.';
  renderAdminPending();
  renderPendingList();
}

function adminReject(utr){
  const key = 'pending_' + utr;
  const data = readJSON(key);
  if(!data){ adminMsg.innerText = 'Pending not found'; return; }
  writeJSON('rejected_' + utr, {utr, coins: data.coins, amount: data.amount, ts: Date.now()});
  localStorage.removeItem(key);
  adminMsg.innerText = 'Rejected UTR ' + utr;
  renderAdminPending();
  renderPendingList();
}

// Buy flow
preset100.onclick = ()=> coinsInput.value = 100;
preset500.onclick = ()=> coinsInput.value = 500;
preset1000.onclick = ()=> coinsInput.value = 1000;

buyBtn.onclick = ()=>{
  let coins = parseInt(coinsInput.value||'0',10);
  if(isNaN(coins) || coins < MIN_COINS){ alert('Minimum 100 coins'); coinsInput.value = MIN_COINS; return; }
  if(coins > MAX_COINS){ alert('Maximum 4000 coins'); coinsInput.value = MAX_COINS; return; }
  // open modal with computed amount
  modalCoins.value = coins;
  modalAmount.value = (coins * PRICE_PER_COIN).toFixed(2);
  modalUTR.value = '';
  modalMsg.innerText = '';
  csNote.style.display = 'none';
  openModal(payModal);
};

// modal submit
modalSubmit.onclick = ()=>{
  const coins = Number(modalCoins.value);
  const amount = Number(modalAmount.value);
  const utr = (modalUTR.value||'').trim();
  if(!/^[0-9]{12}$/.test(utr)){ modalMsg.innerText = 'Enter valid 12-digit UTR'; return; }
  // create pending key
  const key = 'pending_' + utr;
  if(readJSON(key)){ modalMsg.innerText = 'A pending request with this UTR already exists'; return; }
  const payload = { utr, coins, amount, ts: Date.now(), status: 'pending' };
  writeJSON(key, payload);
  modalMsg.innerText = 'Submitted — awaiting admin approval';
  csNote.style.display = 'block';
  renderPendingList();
  closeModal(payModal);
};

// modal close
modalClose.onclick = ()=> closeModal(payModal);

// modal open/close helpers
function openModal(el){ el.classList.add('show'); }
function closeModal(el){ el.classList.remove('show'); }

// predictions: period generator + countdown
// We'll create a period number that increments every minute. Format: YYYYMMDDHHMM + seq
function makePeriodString(){
  const d = new Date();
  // YYYYMMDDHHMM
  const YYYY = d.getFullYear().toString().padStart(4,'0');
  const MM = String(d.getMonth()+1).padStart(2,'0');
  const DD = String(d.getDate()).padStart(2,'0');
  const hh = String(d.getHours()).padStart(2,'0');
  const mi = String(d.getMinutes()).padStart(2,'0');
  // seq: minutes since epoch modulo 100000 (keeps it numeric)
  const seq = String(Math.floor(Date.now()/60000) % 100000).padStart(5,'0');
  return `${YYYY}${MM}${DD}${hh}${mi}${seq}`; // long unique per minute string
}

let countdownInterval = null;
function startPeriodClock(){
  // update immediately
  updatePeriodDisplay();
  if(countdownInterval) clearInterval(countdownInterval);
  countdownInterval = setInterval(()=>{
    updatePeriodDisplay();
  }, 1000);
}

function updatePeriodDisplay(){
  // compute seconds until next minute
  const now = Date.now();
  const next = Math.ceil(now / 60000) * 60000;
  const sec = Math.max(0, Math.round((next - now)/1000));
  countdownEl.innerText = 'Next period in: ' + sec + 's';
  if(sec === 0){
    // period changed
    periodDisplay.innerText = makePeriodString();
  } else {
    // show current minute's period (stable until next)
    periodDisplay.innerText = makePeriodString();
  }
}

// generate prediction (consumes 2 coins)
function loadPredictions(){
  return readJSON('predictions', []);
}
function savePredictions(arr){ writeJSON('predictions', arr); }

function renderPredHistory(){
  const arr = loadPredictions();
  predHistory.innerHTML = '';
  if(arr.length === 0){ predHistory.innerHTML = '<div class="small">No predictions yet</div>'; return; }
  arr.slice(0,20).forEach(p=>{
    const item = document.createElement('div');
    item.style.padding='6px';
    item.style.borderBottom='1px solid rgba(255,255,255,0.03)';
    item.innerHTML = `<div style="display:flex;justify-content:space-between">
      <div><b>${p.period}</b><div class="small">${p.signal} • ${p.nums}</div></div>
      <div class="small">${new Date(p.ts).toLocaleTimeString()}</div>
    </div>`;
    predHistory.appendChild(item);
  });
}

function renderResultsArea(){
  const arr = loadPredictions();
  resultsArea.innerHTML = '';
  if(arr.length === 0){ resultsArea.innerHTML = '<div class="small">No results</div>'; return; }
  arr.slice(0,20).forEach(r=>{
    const div = document.createElement('div');
    div.style.padding='6px';
    div.style.borderBottom='1px solid rgba(255,255,255,0.03)';
    div.innerHTML = `<div style="display:flex;justify-content:space-between">
      <div><strong>${r.period}</strong><div class="small">${r.signal} • ${r.nums}</div></div>
      <div class="small">${new Date(r.ts).toLocaleTimeString()}</div>
    </div>`;
    resultsArea.appendChild(div);
  });
}

generateBtn.onclick = ()=>{
  // check wallet
  const wallet = getWallet();
  if(wallet < PRED_COST){ alert('Not enough coins. Buy coins first.'); return; }
  // require user to enter period3 or allow blank
  const p3 = (period3.value||'').trim();
  // deduct coins immediately
  setWallet(wallet - PRED_COST);
  // create prediction
  const signal = Math.random() < 0.5 ? 'SMALL' : 'BIG';
  let a,b;
  if(signal === 'SMALL'){ a = Math.floor(Math.random()*5); b = Math.floor(Math.random()*5); }
  else { a = 5 + Math.floor(Math.random()*5); b = 5 + Math.floor(Math.random()*5); }
  const periodNow = makePeriodString();
  const nums = `${a} / ${b}`;
  // display
  predictionArea.style.display = 'block';
  predPeriod.innerText = periodNow + (p3 ? (' • ' + p3) : '');
  predSignal.innerText = signal;
  predNums.innerText = nums;
  // store in predictions history
  const arr = loadPredictions();
  arr.unshift({ period: periodNow + (p3 ? ('|' + p3) : ''), signal, nums, ts: Date.now()});
  savePredictions(arr.slice(0,100)); // keep last 100
  renderPredHistory();
  renderResultsArea();
};

// admin modal open
adminCross.onclick = async ()=>{
  const pw = prompt('Enter admin password:');
  if(pw === null) return;
  if(pw !== ADMIN_PASS){ alert('Wrong password'); return; }
  adminMsg.innerText = '';
  renderAdminPending();
  openModal(adminModal);
};
adminClose.onclick = ()=> closeModal(adminModal);

// refresh wallet/pending
refreshWalletBtn.onclick = ()=>{
  updateWalletUI();
  renderPendingList();
  renderPredHistory();
  renderResultsArea();
};

// listen for storage events so if admin approves in another tab, user sees it
window.addEventListener('storage', (ev)=>{
  if(!ev.key) return;
  // if approved_ key added, update wallet UI (we can't identify user per se; we assume single-user)
  if(ev.key.startsWith('approved_')){
    // credit coins from approved entry if wallet hasn't seen it yet
    try{
      const approved = JSON.parse(ev.newValue);
      if(approved && approved.utr){
        // to avoid double-crediting across tabs we only credit if there is still a pending key removed
        // This basic approach is local-only; for multi-user real system use server-side.
        // For now, ensure pending_utr removed and then credit
        const pendingKey = 'pending_' + approved.utr;
        if(!localStorage.getItem(pendingKey)){
          // credit (but only if not previously credited)
          // We'll also set a marker approved_consume_<utr> so we don't credit multiple times in same tab
          const marker = 'approved_consume_' + approved.utr;
          if(!localStorage.getItem(marker)){
            const cur = getWallet();
            setWallet(cur + Number(approved.coins || approved.coins === 0 ? approved.coins : 0));
            localStorage.setItem(marker, '1');
          }
        }
      }
    }catch(e){}
    renderPendingList();
  }
  // if pending removed, update pending list
  if(ev.key && ev.key.startsWith('pending_') === false){
    renderPendingList();
  }
});

// initial setup & helpers
function init(){
  updateWalletUI();
  renderPendingList();
  renderPredHistory();
  renderResultsArea();
  startPeriodClock();
  // set QR src fallback if not set
  if(!qrImage.src || qrImage.src.indexOf('qr.png') === -1){
    qrImage.src = 'qr.png';
  }
}
init();

// convenience: clicking buy opens modal prefilled
// Also show amount when coins input changes
coinsInput.addEventListener('input', ()=>{
  let v = parseInt(coinsInput.value||'0',10);
  if(isNaN(v)) v = MIN_COINS;
  if(v < MIN_COINS) v = MIN_COINS;
  if(v > MAX_COINS) v = MAX_COINS;
  coinsInput.value = v;
});

// small UX: open modal when buy triggered
buyBtn.addEventListener('click', ()=>{
  // handled earlier — modal will open and filled.
});

// helpers to keep things tidy
(function tidyInterval(){
  setInterval(()=>{
    // remove old approved_consume markers older than 7 days (not strictly necessary)
    // (omitted to keep storage simpler)
  }, 24*60*60*1000);
})();

</script>
</body>
</html>
