<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Prediction AI — Professional</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  :root{
    --bg:#071022;
    --card:#0f1724;
    --muted:#9fb0d6;
    --accent1:#00d2a8;
    --accent2:#00a6ff;
    --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  body{margin:0;background:linear-gradient(180deg,#030616,#071022);color:#eaf6ff;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
  .app{width:100%;max-width:1100px}
  .grid{display:grid;grid-template-columns:1fr 420px;gap:18px}
  @media(max-width:980px){.grid{grid-template-columns:1fr}}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;padding:18px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 12px 40px rgba(0,0,0,0.6)}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  .logo{width:54px;height:54px;border-radius:10px;overflow:hidden;background:#09202a;display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,0.04)}
  .h1{font-weight:700;font-size:18px}
  .muted{color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .btn{background:linear-gradient(90deg,var(--accent1),var(--accent2));border:none;padding:10px 12px;border-radius:8px;color:#001;font-weight:800;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  input[type=text]{padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;width:100%}
  .periodRow{display:flex;gap:8px;align-items:center;margin-top:12px}
  .periodRow input{flex:1}
  .historyBox{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .chip{padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);min-width:56px;text-align:center;font-weight:700}
  .chip.big{background:linear-gradient(180deg, rgba(127,232,167,0.12), rgba(127,232,167,0.06));color:#8ff7c6}
  .chip.small{background:linear-gradient(180deg, rgba(255,182,107,0.08), rgba(255,182,107,0.04));color:#ffd7a8}
  .analytics{margin-top:12px;display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .bigPred{font-size:22px;font-weight:900;color:var(--accent1)}
  .conf{font-weight:800}
  canvas{background:transparent;border-radius:8px}
  .log{margin-top:12px;padding:10px;border-radius:8px;background:rgba(0,0,0,0.25);font-size:13px;max-height:160px;overflow:auto}
  .footer{margin-top:12px;text-align:center;color:var(--muted);font-size:13px}
  .flex{display:flex;gap:8px;align-items:center}
  .settings{display:flex;gap:8px;align-items:center;margin-top:8px}
  .badge{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-weight:700}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="logo">AI</div>
    <div>
      <div class="h1">Prediction AI — Professional (Wingo 1min style)</div>
      <div class="muted">Deep analysis over last results • confidence threshold 60%</div>
    </div>
  </header>

  <div class="grid">
    <!-- LEFT: main prediction area -->
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div style="font-weight:800">Prediction Console</div>
          <div class="muted">Enter last results (B for BIG, S for SMALL) — minimum 10 results required</div>
        </div>
        <div class="badge" id="serverStatus">Server: Connected ✅</div>
      </div>

      <div class="periodRow">
        <input id="periodInput" placeholder="Enter full period id (e.g. 20250914100011151)" />
        <button class="btn" id="nextPeriodBtn">Auto Next</button>
      </div>

      <div style="margin-top:10px">
        <div class="muted">Last results (latest on right)</div>
        <div class="historyBox" id="historyBox" aria-live="polite"></div>

        <div style="margin-top:10px;display:flex;gap:8px">
          <input id="manualResultInput" placeholder="Enter B or S" style="width:120px"/>
          <button class="btn ghost" id="addResultBtn">Add Result</button>
          <button class="btn" id="clearBtn">Clear All</button>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="analyzeBtn">Analyze & Predict</button>
        <button class="btn ghost" id="fillDemoBtn">Fill sample last-10</button>
        <div class="muted" style="align-self:center">Confidence threshold: <input id="confThresh" type="text" value="60" style="width:60px;margin-left:8px"/>%</div>
      </div>

      <div class="analytics">
        <div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div class="muted">Prediction</div>
            <div id="predictionBox" class="bigPred">--</div>
          </div>
          <div style="margin-top:8px" class="muted">Confidence: <span id="confText">--</span>%</div>
          <div style="margin-top:10px" id="suggestionText" class="muted"></div>
        </div>
        <div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div class="muted">Bet Suggestion (15/30/55)</div>
            <div id="betSuggest" class="muted">—</div>
          </div>
          <div style="margin-top:8px" class="muted">Balance: <input id="balanceInput" type="text" value="1000" style="width:120px;margin-left:8px"/></div>
        </div>
      </div>

      <div style="margin-top:12px">
        <canvas id="freqChart" height="120"></canvas>
      </div>

      <div class="log" id="logBox"></div>
    </div>

    <!-- RIGHT: sidebar -->
    <div>
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Analysis Breakdown</div>
          <div class="muted">10 modules</div>
        </div>
        <div style="margin-top:10px">
          <div class="muted">Modules run time: <span id="analysisTime">0s</span></div>
          <div style="margin-top:10px" id="modulesList"></div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Results History</div>
          <div class="muted" id="histCount">0</div>
        </div>
        <div style="margin-top:10px">
          <div class="muted">Saved results (latest 50)</div>
          <div class="log" id="savedList" style="max-height:240px"></div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;text-align:center">
        <div style="font-weight:800">Quick Actions</div>
        <div style="margin-top:10px" class="controls">
          <button class="btn ghost" id="exportBtn">Export JSON</button>
          <button class="btn" id="importBtn">Import JSON</button>
        </div>
        <div style="margin-top:10px" class="muted">Auto-save last results to localStorage for AI learning</div>
      </div>
    </div>
  </div>

  <div class="footer">Design: Professional terminal • Analysis: weighted heuristics (hybrid)</div>
</div>

<script>
/* Prediction AI (hybrid heuristics) - client-side
   - Maintains last results array (B/S) and period auto-increment
   - When Analyze: runs multiple modules, computes weighted score for BIG and SMALL
   - Confidence = normalized max score; if >= threshold -> shows prediction
   - Saves history to localStorage 'pa_history' (latest 50)
*/

// helpers
const el = id=>document.getElementById(id);
let history = JSON.parse(localStorage.getItem('pa_last_results')||'[]'); // array of 'B' or 'S' (latest on right)
const modules = [
  'Frequency Analysis', 'Run-Length Analysis', 'Recent Bias',
  'Momentum Trend', 'Entropy (variety)', 'Streak Correction',
  'Opposite-Psychology', 'Weighted Moving Bias', 'Time-based Drift', 'Randomized Tie-break'
];

function saveHistory(){
  localStorage.setItem('pa_last_results', JSON.stringify(history.slice(-50)));
  renderHistory();
  renderSavedList();
}

function renderHistory(){
  const box = el('historyBox');
  box.innerHTML = '';
  if(history.length===0){
    box.innerHTML = '<div class="muted">No results yet</div>'; el('histCount').innerText = '0'; return;
  }
  history.forEach((v,i)=>{
    const d = document.createElement('div');
    d.className = 'chip ' + (v==='B'?'big':'small');
    d.innerText = v;
    box.appendChild(d);
  });
  el('histCount').innerText = history.length;
}

function renderSavedList(){
  const saved = JSON.parse(localStorage.getItem('pa_saved')||'[]');
  const div = el('savedList'); div.innerHTML = '';
  if(!saved.length){ div.innerHTML = '<div class="muted">No saved sessions</div>'; return;}
  saved.slice().reverse().forEach(s=>{
    const row = document.createElement('div');
    row.style.padding='6px 8px';
    row.style.borderBottom='1px solid rgba(255,255,255,0.03)';
    row.innerHTML = `<div><strong>${s.period||'session'}</strong> • ${s.results.join(',')}<div style="font-size:12px;color:#bbb">${new Date(s.ts).toLocaleString()}</div></div>`;
    div.appendChild(row);
  });
}

// UI init
renderHistory();
renderSavedList();
const ctx = el('freqChart').getContext('2d');
const chart = new Chart(ctx, {
  type:'bar',
  data:{labels:['BIG','SMALL'], datasets:[{label:'Frequency',data:[0,0],backgroundColor:['#7fe8a7','#ffb66b']}]},
  options:{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}
});

// utils
function countFreq(arr){ const c={B:0,S:0}; arr.forEach(x=>{ if(x==='B') c.B++; if(x==='S') c.S++; }); return c; }
function runLengths(arr){
  // returns longest run for B and S
  let maxB=0,maxS=0,cur=1;
  for(let i=1;i<arr.length;i++){
    if(arr[i]===arr[i-1]) cur++; else { if(arr[i-1]==='B') maxB=Math.max(maxB,cur); else maxS=Math.max(maxS,cur); cur=1;}
  }
  // last run
  if(arr.length){
    if(arr[arr.length-1]==='B') maxB=Math.max(maxB,cur); else maxS=Math.max(maxS,cur);
  }
  return {maxB,maxS};
}

function entropy(arr){
  const c=countFreq(arr); const total = c.B + c.S;
  if(total===0) return 0;
  const pB = c.B/total, pS = c.S/total;
  let e=0;
  if(pB>0) e -= pB*Math.log2(pB);
  if(pS>0) e -= pS*Math.log2(pS);
  return e; // 0..1
}

function weightedMovingBias(arr, window=5){
  // more weight to recent entries
  let score=0, totalWeight=0;
  const n = Math.min(window, arr.length);
  for(let i=0;i<n;i++){
    const val = arr[arr.length-1 - i];
    const w = (n - i); // descending weight
    if(val==='B') score += w;
    else if(val==='S') score -= w;
    totalWeight += w;
  }
  return score/Math.max(1,totalWeight); // -1 .. 1
}

// main analysis - returns {pred:'B'|'S'|'SKIP', conf:0..100, breakdown:[]}
async function analyzeAndPredict(){
  if(history.length < 10){
    log('Need at least 10 last results to analyze (enter or fill sample).'); return null;
  }
  el('modulesList').innerHTML = '';
  const t0 = performance.now();
  const breakDown = [];
  let scoreB = 0, scoreS = 0;

  // Module 1: Frequency Analysis (weight 1.6)
  {
    const c = countFreq(history);
    const total = c.B + c.S;
    const pB = total? (c.B/total):0.5; const pS = total? (c.S/total):0.5;
    // higher frequency favors that side; but we use psychology: if many bet on side, opposite more likely -> so invert partially
    const invertFactor = 0.28;
    const sB = pB*(1-invertFactor) + (1-pB)*(-invertFactor);
    const sS = pS*(1-invertFactor) + (1-pS)*(-invertFactor);
    scoreB += sB * 1.6;
    scoreS += sS * 1.6;
    breakDown.push(['Frequency', Math.round((pB*100)) + '% B / ' + Math.round((pS*100)) + '% S']);
  }

  // Module 2: Run-Length Analysis (weight 1.4)
  {
    const rl = runLengths(history);
    // long run of B -> likely correction -> favour S
    const adjB = - (rl.maxB / (history.length||1));
    const adjS = - (rl.maxS / (history.length||1));
    scoreB += adjB * 1.4;
    scoreS += adjS * 1.4;
    breakDown.push(['Run-Length', `maxB:${rl.maxB} maxS:${rl.maxS}`]);
  }

  // Module 3: Recent Bias (weight 1.8)
  {
    const recent = history.slice(-7);
    const c = countFreq(recent);
    const pB = (c.B/(c.B+c.S||1));
    const pS = (c.S/(c.B+c.S||1));
    // recent bias slightly inverted (psychology): if recent heavily B, many may keep betting B -> house may flip -> favour S
    const invert = 0.22;
    scoreB += (pB*(1-invert) - pS*invert) * 1.8;
    scoreS += (pS*(1-invert) - pB*invert) * 1.8;
    breakDown.push(['Recent Bias', `last7: ${Math.round(pB*100)}% B`]);
  }

  // Module 4: Momentum Trend (weight 1.2)
  {
    // compute simple trend: moving average sign
    const wmb = weightedMovingBias(history, Math.min(9, history.length));
    // positive -> bias toward B, but invert small amount
    scoreB += (wmb*0.9) * 1.2;
    scoreS += (-wmb*0.9) * 1.2;
    breakDown.push(['Momentum', `wmBias:${wmb.toFixed(2)}`]);
  }

  // Module 5: Entropy (diversity) (weight 1.0)
  {
    const e = entropy(history);
    // low entropy -> clear pattern -> follow pattern slightly (no invert)
    scoreB += ((countFreq(history).B/(history.length||1)) - 0.5) * (1.0*(1.2 - e));
    scoreS += ((countFreq(history).S/(history.length||1)) - 0.5) * (1.0*(1.2 - e));
    breakDown.push(['Entropy', `e:${e.toFixed(2)}`]);
  }

  // Module 6: Streak Correction (weight 1.3)
  {
    const last = history[history.length-1];
    // if last is B and there was a streak, slightly favour opposite
    let streak=1;
    for(let i=history.length-2;i>=0;i--){
      if(history[i]===last) streak++; else break;
    }
    const corr = Math.min(3, streak) * 0.12;
    if(last==='B'){ scoreB -= corr*1.3; scoreS += corr*1.3; }
    else { scoreS -= corr*1.3; scoreB += corr*1.3; }
    breakDown.push(['StreakCorr', `last:${last} streak:${streak}`]);
  }

  // Module 7: Opposite-Psychology (weight 1.6)
  {
    // estimate "where most people will bet" by recent concentration and streaks; then favour opposite
    const c = countFreq(history);
    const total = c.B + c.S;
    const pB = total? c.B/total : 0.5;
    const weightOpp = (Math.abs(pB - 0.5))*1.2; // stronger when skewed
    scoreB += (0.5 - pB) * weightOpp * 1.6;
    scoreS += (pB - 0.5) * weightOpp * 1.6;
    breakDown.push(['OppositePsych', `conc:${Math.round(pB*100)}% B`]);
  }

  // Module 8: Weighted Moving Bias (weight 1.2)
  {
    const wmb = weightedMovingBias(history, Math.min(11, history.length));
    scoreB += (wmb*0.7) * 1.2;
    scoreS += (-wmb*0.7) * 1.2;
    breakDown.push(['WMovBias', `wm:${wmb.toFixed(2)}`]);
  }

  // Module 9: Time-based Drift (weight 0.8)
  {
    // simulate small drift randomness over time to avoid fixed cycles
    const drift = (Math.sin(Date.now()/60000) ) * 0.05;
    scoreB += drift * 0.8;
    scoreS -= drift * 0.8;
    breakDown.push(['TimeDrift', `drift:${drift.toFixed(2)}`]);
  }

  // Module 10: Randomized Tie-break (weight 0.5)
  {
    const rnd = (Math.random()-0.5) * 0.4;
    scoreB += rnd * 0.5;
    scoreS -= rnd * 0.5;
    breakDown.push(['RandomTie', `rnd:${rnd.toFixed(2)}`]);
  }

  // final scoring normalization
  const rawB = scoreB, rawS = scoreS;
  const expB = Math.exp(rawB);
  const expS = Math.exp(rawS);
  const pB = expB/(expB+expS);
  const pS = expS/(expB+expS);
  const conf = Math.round(Math.max(pB,pS)*100);
  const pred = pB>pS ? 'B' : 'S';

  // assemble module outputs to UI gradually to mimic analysis time
  const start = performance.now();
  el('modulesList').innerHTML = '';
  for(let i=0;i<breakDown.length;i++){
    ((i)=>{
      setTimeout(()=>{
        const m = document.createElement('div');
        m.className = 'muted';
        m.style.marginTop='6px';
        m.innerText = `${i+1}. ${breakDown[i][0]} — ${breakDown[i][1]}`;
        el('modulesList').appendChild(m);
      }, i*400);
    })(i);
  }

  // simulate wait time 8-14s depending on array length
  const simTime = 8000 + Math.min(8000, history.length*250);
  await new Promise(r=>setTimeout(r, simTime));

  const t1 = performance.now();
  const timeSec = ((t1 - t0)/1000).toFixed(1);
  el('analysisTime').innerText = timeSec + 's';
  el('predictionBox').innerText = pred === 'B' ? 'BIG' : 'SMALL';
  el('confText').innerText = conf;
  el('betSuggest').innerText = suggestBetAmounts();
  el('suggestionText').innerText = `Top modules indicate: ${breakDown[0][1]}`;
  log(`Analysis finished in ${timeSec}s — Pred: ${pred} Conf: ${conf}%`);

  // update chart
  const cf = countFreq(history);
  chart.data.datasets[0].data = [cf.B, cf.S];
  chart.update();

  return {pred, conf, pB, pS, rawB, rawS};
}

function suggestBetAmounts(){
  const bal = Number(el('balanceInput').value) || 0;
  const a = Math.max(1, Math.round(bal * 0.15));
  const b = Math.max(1, Math.round(bal * 0.30));
  const c = Math.max(1, Math.round(bal * 0.55));
  return `${a} / ${b} / ${c}`;
}

function log(msg){
  const box = el('logBox');
  const row = document.createElement('div');
  row.style.padding='6px 0';
  row.style.borderBottom='1px dashed rgba(255,255,255,0.03)';
  row.innerText = `${new Date().toLocaleTimeString()} — ${msg}`;
  box.prepend(row);
}

// UI bindings
el('addResultBtn').addEventListener('click', ()=>{
  const v = (el('manualResultInput').value||'').trim().toUpperCase();
  if(!v || !['B','S'].includes(v)){ alert('Enter B or S'); return; }
  history.push(v);
  if(history.length>50) history.shift();
  el('manualResultInput').value='';
  saveHistory();
  log('Added result ' + v);
});
el('clearBtn').addEventListener('click', ()=>{ if(!confirm('Clear history?')) return; history=[]; saveHistory(); log('History cleared'); });

el('fillDemoBtn').addEventListener('click', ()=>{ history = ['B','S','B','B','S','B','S','B','S','B']; saveHistory(); log('Filled demo last-10'); });

el('analyzeBtn').addEventListener('click', async ()=>{
  const thr = Number(el('confThresh').value)||60;
  el('predictionBox').innerText = '...';
  el('confText').innerText = '--';
  el('modulesList').innerHTML = '';
  el('suggestionText').innerText = 'Analyzing...';
  const res = await analyzeAndPredict();
  if(!res) return;
  if(res.conf >= thr){
    el('predictionBox').innerText = (res.pred==='B' ? 'BIG' : 'SMALL');
    el('confText').innerText = res.conf;
    // save to saved sessions store
    const saved = JSON.parse(localStorage.getItem('pa_saved')||'[]');
    saved.push({ts:Date.now(),period:el('periodInput').value||'',results:history.slice(-20),pred:res.pred,conf:res.conf});
    localStorage.setItem('pa_saved', JSON.stringify(saved.slice(-200)));
    renderSavedList();
    // show brief log
    log(`Predicted ${(res.pred==='B'?'BIG':'SMALL')} at ${res.conf}%`);
  } else {
    el('suggestionText').innerText = 'Low confidence — suggestion: SKIP (or collect more data)';
    el('predictionBox').innerText = 'SKIP';
    el('confText').innerText = res.conf;
    log(`Low confidence (${res.conf}%) — SKIP`);
  }
});

// export/import
el('exportBtn').addEventListener('click', ()=>{
  const payload = {history, saved: JSON.parse(localStorage.getItem('pa_saved')||'[]')};
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'pa_export.json'; a.click();
  URL.revokeObjectURL(url);
});

el('importBtn').addEventListener('click', ()=>{
  const inp = document.createElement('input'); inp.type='file'; inp.accept='application/json';
  inp.onchange = e=>{
    const f = e.target.files[0];
    if(!f) return;
    const r = new FileReader();
    r.onload = ev=>{
      try{
        const obj = JSON.parse(ev.target.result);
        if(obj.history) history = obj.history.slice(-50);
        if(obj.saved) localStorage.setItem('pa_saved', JSON.stringify(obj.saved));
        saveHistory(); renderSavedList();
        alert('Imported');
      }catch(er){ alert('Invalid file'); }
    };
    r.readAsText(f);
  };
  inp.click();
});

// auto-next period: increments numeric suffix by 1
el('nextPeriodBtn').addEventListener('click', ()=>{
  const v = el('periodInput').value.trim();
  if(!v){ alert('Enter current period first'); return; }
  const next = incrementPeriodString(v);
  el('periodInput').value = next;
  log('Auto-next -> ' + next);
});

function incrementPeriodString(str){
  // find trailing digits chunk and increment by 1 preserving leading zeros
  const m = str.match(/(.*?)(\d+)$/);
  if(!m) return str + '1';
  const prefix = m[1], digits = m[2];
  const num = BigInt(digits) + 1n;
  const s = num.toString().padStart(digits.length, '0');
  return prefix + s;
}

// load saved history on start
(function init(){
  try{ history = JSON.parse(localStorage.getItem('pa_last_results')||'[]'); }catch(e){ history = []; }
  renderHistory();
  renderSavedList();
  const cf = countFreq(history);
  chart.data.datasets[0].data = [cf.B, cf.S];
  chart.update();
  log('Ready — loaded history length ' + history.length);
})();

</script>
</body>
</html>   
  
