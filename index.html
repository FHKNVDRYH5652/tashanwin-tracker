<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Wingo 1-Min Predictor - Hacker Mode</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 0;
    }
    iframe {
      width: 100%;
      height: 250px;
      border: none;
    }
    .container {
      padding: 20px;
    }
    textarea {
      width: 100%;
      height: 250px;
      background: #111;
      color: #0f0;
      border: 1px solid #0f0;
      padding: 10px;
      margin-bottom: 10px;
    }
    button {
      padding: 10px 20px;
      background: #0f0;
      color: #000;
      border: none;
      font-weight: bold;
      cursor: pointer;
    }
    #result, #indicators {
      background: #111;
      padding: 15px;
      margin-top: 15px;
      border: 1px solid #0f0;
    }
    h2, h3 {
      color: #0f0;
    }
  </style>
</head>
<body>

  <!-- TashanWin Game Page -->
  <iframe src="https://www.tashanwin.org/#/register?invitationCode=13413405256"></iframe>

  <div class="container">
    <h2>🎯 Wingo Color Trading - Smart Predictor</h2>

    <!-- Data Input -->
    <textarea id="inputData" placeholder="Paste game results here. Format: *Period\nNumber\nBig/Small\n..."></textarea>
    
    <!-- Optional Bet Bias Input -->
    <textarea id="betInput" placeholder="Enter bet volume estimate (e.g., Big:70 Small:30 or Red:60 Green:40)"></textarea>
    
    <button onclick="runPrediction()">Predict Next</button>

    <!-- Prediction Output -->
    <div id="result"></div>

    <!-- Indicator Panel -->
    <div id="indicators"></div>
  </div>

  <script>
    function parseData(data) {
      const lines = data.trim().split("\n");
      const results = [];
      for (let i = 0; i < lines.length; i += 3) {
        const period = lines[i].replace("*", "").trim();
        const number = parseInt(lines[i + 1]);
        const size = lines[i + 2].trim();
        if (!isNaN(number)) results.push({ period, number, size });
      }
      return results;
    }

    function getNextPeriod(current) {
      let num = parseInt(current.replace("010", ""));
      return "*010" + (num + 1).toString().padStart(3, "0");
    }

    function analyzeStreak(data) {
      let streak = 1;
      const base = data[0].size;
      for (let i = 1; i < data.length; i++) {
        if (data[i].size === base) streak++;
        else break;
      }
      return { type: base, count: streak };
    }

    function getHotCold(numbers) {
      const freq = {};
      numbers.forEach(n => freq[n] = (freq[n] || 0) + 1);
      const sorted = Object.entries(freq).sort((a, b) => b[1] - a[1]);
      return {
        hot: sorted[0]?.[0],
        cold: sorted[sorted.length - 1]?.[0]
      };
    }

    function detectPattern(data) {
      const recent = data.slice(0, 5).map(d => d.size);
      if (recent.every(s => s === recent[0])) return `5x ${recent[0]}`;
      if (recent[0] === recent[2] && recent[1] === recent[3]) return `Alt Pattern`;
      return "No strong pattern";
    }

    function parseBetBias(input) {
      const bias = { big: 0, small: 0 };
      const match = input.match(/Big[:\s]?(\d+)[,\s]+Small[:\s]?(\d+)/i);
      if (match) {
        bias.big = parseInt(match[1]);
        bias.small = parseInt(match[2]);
      }
      return bias;
    }

    function predictNext(data, betBias) {
      const numbers = data.map(r => r.number);
      const sizes = data.map(r => r.size);

      // Hot/Cold
      const { hot, cold } = getHotCold(numbers);

      // Basic logics
      const lastNum = numbers[0];
      const predList = [
        parseInt(hot),
        (lastNum + 1) % 10,
        (lastNum + 2) % 10,
        (lastNum + numbers[1]) % 10,
        (lastNum * 2) % 10,
        (9 - lastNum),
        (numbers[0] + numbers[1] + numbers[2]) % 10
      ];

      // Mode of predictions
      const count = {};
      predList.forEach(n => count[n] = (count[n] || 0) + 1);
      const finalNum = parseInt(Object.entries(count).sort((a, b) => b[1] - a[1])[0][0]);

      // Size prediction
      let finalSize = finalNum >= 5 ? 'Big' : 'Small';

      // Manipulation-based logic
      if (betBias.big > betBias.small) finalSize = 'Small';
      else if (betBias.small > betBias.big) finalSize = 'Big';

      return { number: finalNum, size: finalSize };
    }

    function runPrediction() {
      const rawData = document.getElementById("inputData").value;
      const betRaw = document.getElementById("betInput").value;
      const data = parseData(rawData);

      if (data.length < 5) {
        alert("Please enter at least 5 rounds of data.");
        return;
      }

      const betBias = parseBetBias(betRaw);
      const next = getNextPeriod(data[0].period);
      const prediction = predictNext(data, betBias);
      const streak = analyzeStreak(data);
      const pattern = detectPattern(data);
      const { hot, cold } = getHotCold(data.map(r => r.number));

      // Result output
      document.getElementById("result").innerHTML = `
        <h3>🧠 Prediction for ${next}</h3>
        <p>🎲 <b>Number:</b> ${prediction.number}</p>
        <p>📈 <b>Size:</b> ${prediction.size}</p>
        <p>💰 <b>Suggested Bet:</b> Go <b>${prediction.size}</b> side</p>
      `;

      // Indicators
      document.getElementById("indicators").innerHTML = `
        <p>🔥 <b>Hot Number:</b> ${hot}</p>
        <p>❄️ <b>Cold Number:</b> ${cold}</p>
        <p>🔁 <b>Current Streak:</b> ${streak.count} x ${streak.type}</p>
        <p>🧬 <b>Pattern:</b> ${pattern}</p>
        <p>📊 <b>Bet Bias:</b> Big: ${betBias.big || 0}, Small: ${betBias.small || 0}</p>
      `;
    }
  </script>

</body>
</html>
