<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wingo Predictor — Deep Analyzer</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700;800&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  :root{
    --bg:#071021;
    --panel:#0f1724;
    --accent:#00d2a8;
    --accent2:#00a6ff;
    --muted:#9fb0d6;
    --danger:#ff6b6b;
  }
  *{box-sizing:border-box;font-family:'Inter',system-ui,Segoe UI,Roboto,Arial;}
  body{margin:0;background:linear-gradient(180deg,#05101a,#071827);color:#e6f3ff;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px}
  .app{width:1100px;max-width:98%;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:18px;box-shadow:0 12px 40px rgba(0,0,0,0.6)}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  .logo{width:56px;height:56px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent2));display:flex;align-items:center;justify-content:center;font-weight:800;color:#012}
  h1{margin:0;font-size:18px}
  .top-row{display:flex;gap:12px}
  .left, .right{background:var(--panel);padding:12px;border-radius:10px;flex:1}
  .right{width:420px;flex:0 0 420px}
  label{display:block;color:var(--muted);font-size:13px;margin-bottom:6px}
  .last-list{display:flex;flex-wrap:wrap;gap:6px}
  .chip{padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);cursor:pointer;user-select:none}
  .chip.big{background:linear-gradient(90deg,#063,#06a);color:#021}
  .chip.small{background:linear-gradient(90deg,#ffd54a,#ffb66b);color:#071}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
  input[type=text]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  button{padding:8px 12px;border-radius:8px;border:none;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#012;font-weight:700;cursor:pointer}
  .muted{color:var(--muted);font-size:13px}
  .panel-box{background:rgba(255,255,255,0.01);padding:12px;border-radius:10px;margin-top:12px}
  .analysis-area{margin-top:12px}
  .big-stat{font-size:24px;font-weight:800}
  .conf{font-weight:800;padding:6px 10px;border-radius:8px;display:inline-block}
  .conf.high{background:linear-gradient(90deg,#7fe8a7,#bff7dc);color:#012}
  .conf.mid{background:linear-gradient(90deg,#ffd54a,#ffb66b);color:#012}
  .conf.low{background:linear-gradient(90deg,#ff9a9a,#ff6b6b);color:#012}
  .analysis-logs{font-family:monospace;background:rgba(0,0,0,0.18);padding:10px;border-radius:8px;margin-top:8px;max-height:220px;overflow:auto}
  .chart-wrap{height:180px;margin-top:12px}
  footer{margin-top:12px;text-align:center;color:var(--muted);font-size:13px}
  .hint{font-size:12px;color:#c9d7e9}
  .server-status{float:right;font-size:13px;color:#9ff}
  .skip-box{display:inline-block;padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
  .result-row{display:flex;gap:8px;align-items:center;margin-top:8px}
  .green{color:#8fffb2}
  .red{color:#ff9a9a}
</style>
</head>
<body>
  <div class="app" role="application">
    <header>
      <div class="logo">W</div>
      <div>
        <h1>Wingo — Deep Predictor</h1>
        <div class="muted">Last-20 analysis • Psychology-opposite heuristic • Beast-mode recovery</div>
      </div>
      <div class="server-status" id="serverStatus">Server: Local</div>
    </header>

    <div class="top-row">
      <div class="left">
        <label>Period (enter current period number)</label>
        <div style="display:flex;gap:8px;align-items:center">
          <input id="periodInput" type="text" placeholder="e.g. 20250914100011162" style="flex:1"/>
          <button id="incPeriod">+1</button>
        </div>

        <div class="panel-box">
          <label>Last results (click to toggle Big / Small). Enter up to 20 (latest at right):</label>
          <div id="lastList" class="last-list" aria-live="polite"></div>
          <div class="controls">
            <button id="addBig">Add BIG</button>
            <button id="addSmall">Add SMALL</button>
            <button id="clearLast">Clear</button>
            <div style="flex:1"></div>
            <div class="muted">Stored locally</div>
          </div>
        </div>

        <div class="panel-box">
          <label>Analysis controls</label>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="generateBtn">Generate Prediction (Deep Analyze)</button>
            <div class="hint">Takes ~10-15s to simulate deep analysis</div>
          </div>

          <div class="analysis-area" id="analysisArea" style="display:none">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div>
                <div class="muted">Prediction</div>
                <div class="big-stat" id="predictionLabel">--</div>
              </div>
              <div style="text-align:right">
                <div class="muted">Confidence</div>
                <div id="confLabel" class="conf">--</div>
              </div>
            </div>

            <div class="result-row">
              <div class="skip-box" id="suggestionBox">Suggestion: --</div>
              <div style="flex:1"></div>
              <div class="muted">Beast Mode: <span id="beastMode">OFF</span></div>
            </div>

            <div class="chart-wrap">
              <canvas id="freqChart"></canvas>
            </div>

            <div class="analysis-logs" id="logBox" aria-live="polite"></div>

            <div style="margin-top:10px;display:flex;gap:8px">
              <button id="markWin" style="background:linear-gradient(90deg,#7fe8a7,#bff7dc);color:#012">Mark WIN</button>
              <button id="markLoss" style="background:linear-gradient(90deg,#ff9a9a,#ff6b6b);color:#012">Mark LOSS</button>
              <div style="flex:1"></div>
              <button id="exportBtn" class="muted">Export history</button>
            </div>
          </div>
        </div>

      </div>

      <div class="right">
        <label>Summary & stats</label>
        <div style="display:flex;gap:8px;align-items:center">
          <div style="flex:1">
            <div class="muted">Total stored rounds</div>
            <div id="totalRounds" style="font-weight:800">0</div>
          </div>
          <div style="flex:1">
            <div class="muted">Consecutive losses</div>
            <div id="consecLoss" style="font-weight:800">0</div>
          </div>
        </div>

        <div class="panel-box">
          <label>Quick heuristics (visible)</label>
          <div id="heuristics" class="muted" style="font-size:13px;line-height:1.5"></div>
        </div>

        <div class="panel-box">
          <label>Last results list (most recent at top)</label>
          <div id="historyBox" style="max-height:220px;overflow:auto;font-family:monospace;font-size:13px"></div>
        </div>

        <div class="panel-box">
          <label>Settings</label>
          <div style="display:flex;flex-direction:column;gap:8px">
            <div><label class="muted">Confidence threshold for auto-skip</label>
              <input id="threshold" type="text" value="0.75" placeholder="0.7" />
            </div>
            <div><label class="muted">Enable beast-mode recovery?</label>
              <select id="beastToggle"><option value="1">Yes</option><option value="0">No</option></select>
            </div>
          </div>
        </div>

        <div style="margin-top:12px" class="muted">Note: This tool provides analysis & suggestions. It does NOT guarantee outcomes. Use responsibly.</div>
      </div>
    </div>

    <footer>Built for analysis • Deep heuristics • Last results persisted locally</footer>
  </div>

<script>
/*
  Wingo Predictor — single-file
  - lastResults stored in localStorage (array of 'BIG' or 'SMALL', latest at end)
  - generatePrediction() runs multiple heuristic scorers, weights them, produces P(BIG) and P(SMALL)
  - prediction = argmax, confidence = maxP
  - if confidence < threshold => Suggest SKIP
  - Mark WIN/LOSS to add real outcome and update history
  - Chart shows frequency and moving trend
*/

const MAX_HISTORY = 200;
const MAX_INPUT = 20;

const lastKey = 'wingo_last_results_v1';
const lossKey = 'wingo_consec_loss_v1';

function readLast(){
  try { return JSON.parse(localStorage.getItem(lastKey) || '[]'); } catch(e){ return []; }
}
function writeLast(arr){
  localStorage.setItem(lastKey, JSON.stringify(arr.slice(-MAX_HISTORY)));
}
function readLoss(){ return parseInt(localStorage.getItem(lossKey) || '0',10); }
function writeLoss(n){ localStorage.setItem(lossKey, String(n)); }

const lastListEl = document.getElementById('lastList');
const historyBox = document.getElementById('historyBox');
const totalRounds = document.getElementById('totalRounds');
const consecLoss = document.getElementById('consecLoss');
const heuristics = document.getElementById('heuristics');

const analysisArea = document.getElementById('analysisArea');
const predictionLabel = document.getElementById('predictionLabel');
const confLabel = document.getElementById('confLabel');
const suggestionBox = document.getElementById('suggestionBox');
const logBox = document.getElementById('logBox');
const beastModeLabel = document.getElementById('beastMode');

const periodInput = document.getElementById('periodInput');
const thresholdInput = document.getElementById('threshold');
const beastToggle = document.getElementById('beastToggle');

let chart = null;
let isAnalyzing = false;
let lastResults = readLast();
let consecutiveLosses = readLoss();

function renderLastList(){
  lastListEl.innerHTML = '';
  // show up to MAX_INPUT most recent, latest at right (user wanted latest to right)
  const arr = lastResults.slice(-MAX_INPUT);
  arr.forEach((v, i) => {
    const btn = document.createElement('div');
    btn.className = 'chip ' + (v === 'BIG' ? 'big' : 'small');
    btn.title = 'Click to toggle or remove';
    btn.textContent = v === 'BIG' ? 'BIG' : 'SMALL';
    btn.onclick = ()=> {
      // toggle if clicked
      const idx = lastResults.indexOf(arr[i], lastResults.length - arr.length);
      if(idx >= 0){
        lastResults[idx] = (lastResults[idx] === 'BIG' ? 'SMALL' : 'BIG');
      }
      writeLast(lastResults);
      renderAll();
    };
    btn.oncontextmenu = (ev) => { ev.preventDefault(); // right click remove this one
      const idx = lastResults.indexOf(arr[i], lastResults.length - arr.length);
      if(idx >= 0){ lastResults.splice(idx,1); writeLast(lastResults); renderAll(); }
    };
    lastListEl.appendChild(btn);
  });
  totalRounds.textContent = lastResults.length;
}

function renderHistory(){
  historyBox.innerHTML = '';
  const arr = lastResults.slice().reverse(); // recent first
  arr.forEach((v, i) => {
    const d = document.createElement('div');
    d.textContent = `${lastResults.length - i}: ${v}`;
    historyBox.appendChild(d);
  });
  consecLoss.textContent = consecutiveLosses;
}

function log(msg){
  const line = document.createElement('div');
  const t = new Date().toLocaleTimeString();
  line.textContent = `[${t}] ${msg}`;
  logBox.prepend(line);
  // trim logs
  while(logBox.children.length > 200) logBox.removeChild(logBox.lastChild);
}

function addResult(side){
  if(side !== 'BIG' && side !== 'SMALL') return;
  lastResults.push(side);
  if(lastResults.length > MAX_HISTORY) lastResults.shift();
  writeLast(lastResults);
  renderAll();
}

document.getElementById('addBig').onclick = ()=> addResult('BIG');
document.getElementById('addSmall').onclick = ()=> addResult('SMALL');
document.getElementById('clearLast').onclick = ()=>{
  if(!confirm('Clear last results?')) return;
  lastResults = [];
  writeLast(lastResults);
  consecutiveLosses = 0;
  writeLoss(consecutiveLosses);
  renderAll();
};

document.getElementById('incPeriod').onclick = ()=>{
  const p = periodInput.value.trim();
  if(!p) { alert('Enter period first'); return; }
  // naive increment last digit (works unless format differs) — do numeric add
  const n = BigInt(p) + 1n;
  periodInput.value = String(n);
};

function patternAnalysis(arr){
  // returns object of heuristic outputs, each returns score pair [scoreBig, scoreSmall] (higher positive favors that side)
  const heur = {};
  const N = arr.length;
  const counts = {BIG:0, SMALL:0};
  arr.forEach(x => counts[x] = (counts[x]||0) + 1);

  // 1) Frequency (recent count)
  heur.freq = [counts.BIG / Math.max(1,N), counts.SMALL / Math.max(1,N)];

  // 2) Recency bias (last 6)
  const last6 = arr.slice(-6);
  const rec = {BIG:0,SMALL:0};
  last6.forEach(x=> rec[x]++);
  heur.recency = [rec.BIG/6, rec.SMALL/6];

  // 3) Run-length (long runs -> crowd expects opposite)
  let maxRun = 0, curRun = 1, curVal = arr[0];
  for(let i=1;i<arr.length;i++){
    if(arr[i]===arr[i-1]) curRun++; else { if(curRun>maxRun) maxRun=curRun; curRun=1; }
  }
  if(curRun>maxRun) maxRun = curRun;
  // if there is a very long run of BIG, then opposite might be likely
  const runScore = Math.min(1, maxRun/6); // normalized
  // assign to favor opposite of last value
  const last = arr[arr.length-1];
  heur.run = last === 'BIG' ? [ -runScore, runScore ] : [ runScore, -runScore ];

  // 4) Zig-zag detection (alternating): if alternating, next likely alternate
  let zig = 0; for(let i=2;i<arr.length;i++) if(arr[i]!==arr[i-1] && arr[i-1]!==arr[i-2]) zig++;
  const zigScore = Math.min(1, zig / Math.max(1, arr.length/2));
  // if last two were alternating, prefer opposite of last
  heur.zig = last6.length>=2 && last6[last6.length-1]!==last6[last6.length-2] ? (last==='BIG' ? [ -zigScore, zigScore ] : [ zigScore, -zigScore ]) : [0,0];

  // 5) Momentum (if frequency strongly biased)
  const diff = (counts.BIG - counts.SMALL) / Math.max(1,N);
  heur.momentum = diff > 0 ? [ Math.min(1, diff), -Math.min(1, diff) ] : [ -Math.min(1, -diff), Math.min(1, -diff) ];

  // 6) Psychological crowd-opposite heuristic: assume crowd follows recent frequency; we go opposite of majority
  const majority = counts.BIG > counts.SMALL ? 'BIG' : (counts.SMALL > counts.BIG ? 'SMALL' : 'NONE');
  const majStrength = Math.abs(counts.BIG - counts.SMALL) / Math.max(1,N);
  heur.psych = majority === 'BIG' ? [ -majStrength, majStrength ] : (majority === 'SMALL' ? [ majStrength, -majStrength ] : [0,0]);

  // 7) Pattern library (simple patterns like double, triple)
  // detect sequences of two or three at end
  const end2 = arr.slice(-2).join(',');
  const end3 = arr.slice(-3).join(',');
  let pattScoreB = 0, pattScoreS = 0;
  if(end3 === 'BIG,BIG,BIG') { pattScoreB = 0.2; pattScoreS = -0.2; }
  if(end3 === 'SMALL,SMALL,SMALL') { pattScoreS = 0.2; pattScoreB = -0.2; }
  if(end2 === 'BIG,BIG') { pattScoreB = -0.1; pattScoreS = 0.1; } // often will flip
  if(end2 === 'SMALL,SMALL') { pattScoreS = -0.1; pattScoreB = 0.1; }
  heur.pattern = [pattScoreB, pattScoreS];

  // 8) Frequency trend (moving average difference)
  const mid = Math.max(1, Math.floor(arr.length/2));
  const firstHalf = arr.slice(0, mid), secondHalf = arr.slice(mid);
  const fh = {BIG:0,SMALL:0}, sh={BIG:0,SMALL:0};
  firstHalf.forEach(x=>fh[x]++);
  secondHalf.forEach(x=>sh[x]++);
  const trendB = (sh.BIG/Math.max(1,secondHalf.length)) - (fh.BIG/Math.max(1,firstHalf.length));
  const trendS = (sh.SMALL/Math.max(1,secondHalf.length)) - (fh.SMALL/Math.max(1,firstHalf.length));
  heur.trend = [trendB, trendS];

  // 9) Frequency normalized
  heur.freqNorm = [counts.BIG / Math.max(1,N), counts.SMALL / Math.max(1,N)];

  // 10) Randomness detector — if too random, encourage skip
  const entropy = calcEntropy(arr);
  heur.randomness = entropy; // 0..1

  return heur;
}

function calcEntropy(arr){
  if(arr.length===0) return 0;
  const c = {BIG:0,SMALL:0};
  arr.forEach(x=>c[x]++);
  const p1 = c.BIG/arr.length, p2 = c.SMALL/arr.length;
  // binary entropy normalized to 1
  const h = -( (p1>0? p1*Math.log2(p1):0) + (p2>0? p2*Math.log2(p2):0) );
  const hmax = 1; // for 2 symbols max entropy =1
  return h / hmax;
}

function combineHeuristics(heur){
  // define weights for each heuristic (tuneable)
  const weights = {
    freq: 0.9,
    recency: 0.9,
    run: 0.8,
    zig: 0.6,
    momentum: 0.7,
    psych: 1.0,
    pattern: 0.7,
    trend: 0.6,
    freqNorm: 0.9,
    randomness: -0.8 // negative weight: higher randomness reduces confidence and pushes skip
  };
  const keys = Object.keys(heur);
  let scoreB = 0, scoreS = 0, totalW = 0;
  keys.forEach(k=>{
    const val = heur[k];
    if(k === 'randomness'){
      // randomness is scalar 0..1; we use to reduce confidence not to add to absolute scores
      return;
    }
    const w = weights[k] || 0.5;
    scoreB += (val[0] || 0) * w;
    scoreS += (val[1] || 0) * w;
    totalW += Math.abs(w);
  });
  // incorporate randomness to damp scores
  const rand = heur.randomness;
  const damp = 1 - Math.min(0.85, rand*weights.randomness*-1); // randomness reduces effective score
  scoreB *= damp;
  scoreS *= damp;

  // normalize into probabilities with softmax
  const expB = Math.exp(scoreB);
  const expS = Math.exp(scoreS);
  const pB = expB / (expB + expS);
  const pS = expS / (expB + expS);
  return {pB, pS, raw: [scoreB, scoreS], damp, scoreB, scoreS};
}

function simulateDeepAnalysis(){
  // simulate 10-15s of analysis with logs populating
  logBox.innerHTML = '';
  analysisArea.style.display = 'block';
  predictionLabel.textContent = '--';
  confLabel.textContent = '--';
  suggestionBox.textContent = 'Analyzing...';
  suggestionBox.style.opacity = 0.9;
  isAnalyzing = true;
  const steps = 10 + Math.floor(Math.random()*6);
  let step = 0;

  const timer = setInterval(()=>{
    step++;
    // create a fake sub-heuristic message
    const msgs = [
      'Scanning frequency & recency...',
      'Detecting run-lengths & streaks...',
      'Analyzing zig-zag and pattern library...',
      'Estimating crowd psychology & bias...',
      'Projecting momentum & trend...',
      'Computing confidence surface...',
      'Performing Monte-Carlo style checks...',
      'Normalizing scores, applying dampening...',
      'Final aggregation & calibration...',
      'Preparing suggestion & risk control...'
    ];
    log(msgs[step % msgs.length]);
    if(step >= steps){
      clearInterval(timer);
      isAnalyzing = false;
      finalizePrediction();
    }
  }, 1000 + Math.floor(Math.random()*400));
}

function finalizePrediction(){
  const arr = lastResults.slice(-MAX_INPUT);
  if(arr.length === 0){
    alert('Enter at least one last result (ideally 10-20) before generating.');
    suggestionBox.textContent = 'No data';
    return;
  }
  const heur = patternAnalysis(arr);
  const comb = combineHeuristics(heur);

  // beast mode: boost opposite if consecutiveLosses>=1 and setting enabled
  const beastEnabled = (beastToggle.value === '1');
  if(beastEnabled && consecutiveLosses >= 1){
    // increase opposite weight
    const last = arr[arr.length-1];
    if(last === 'BIG'){ comb.pS += 0.07; comb.pB -= 0.07; }
    else { comb.pB += 0.07; comb.pS -= 0.07; }
    // renormalize
    const sum = comb.pB + comb.pS;
    comb.pB /= sum; comb.pS /= sum;
    beastModeLabel.textContent = 'ON';
  } else {
    beastModeLabel.textContent = 'OFF';
  }

  const pred = comb.pB > comb.pS ? 'BIG' : 'SMALL';
  const confidence = Math.max(comb.pB, comb.pS); // 0..1
  predictionLabel.textContent = pred;
  const confNum = Math.round(confidence*100);
  confLabel.textContent = confNum + '%';
  confLabel.className = 'conf ' + (confidence >= 0.85 ? 'high' : (confidence >= 0.7 ? 'mid' : 'low'));

  // suggestion logic
  const threshold = parseFloat(thresholdInput.value) || 0.75;
  let suggestion = '';
  if(confidence < threshold){
    suggestion = 'SKIP (low confidence)';
  } else {
    suggestion = `BET ${pred} (confidence ${confNum}%)`;
  }
  suggestionBox.textContent = 'Suggestion: ' + suggestion;

  // produce readable heuristic report
  heuristics.innerHTML = '';
  heuristics.innerHTML += `Frequency BIG:${Math.round(heur.freqNorm[0]*100)}% SMALL:${Math.round(heur.freqNorm[1]*100)}%<br/>`;
  heuristics.innerHTML += `Recency last6 BIG:${Math.round(heur.recency[0]*100)}% SMALL:${Math.round(heur.recency[1]*100)}%<br/>`;
  heuristics.innerHTML += `Run influence:${Math.round(heur.run[0]*100)/100},${Math.round(heur.run[1]*100)/100}<br/>`;
  heuristics.innerHTML += `ZigScore:${Math.round(heur.zig[0]*100)/100},${Math.round(heur.zig[1]*100)/100}<br/>`;
  heuristics.innerHTML += `Entropy (randomness): ${Math.round(heur.randomness*100)/100}<br/>`;
  heuristics.innerHTML += `Momentum:${Math.round(heur.momentum[0]*100)/100},${Math.round(heur.momentum[1]*100)/100}<br/>`;

  log(`P(BIG)=${(comb.pB*100).toFixed(1)}%  P(SMALL)=${(comb.pS*100).toFixed(1)}%  => ${pred} @ ${confNum}%`);
  renderChart();
}

document.getElementById('generateBtn').onclick = ()=>{
  if(isAnalyzing) return alert('Analysis already running...');
  log('Start deep analysis...');
  simulateDeepAnalysis();
};

document.getElementById('markWin').onclick = ()=>{
  // mark the last prediction as win: the predicted side happened
  const pred = predictionLabel.textContent;
  if(!pred || pred === '--') { alert('No prediction to mark. Generate first.'); return; }
  // push this actual result to history
  addResult(pred);
  consecutiveLosses = 0;
  writeLoss(consecutiveLosses);
  renderAll();
  log(`Marked WIN for ${pred}`);
};

document.getElementById('markLoss').onclick = ()=>{
  // mark loss for last prediction — actual was opposite
  const pred = predictionLabel.textContent;
  if(!pred || pred === '--') { alert('No prediction to mark. Generate first.'); return; }
  const actual = (pred === 'BIG') ? 'SMALL' : 'BIG';
  addResult(actual);
  consecutiveLosses = readLoss() + 1;
  writeLoss(consecutiveLosses);
  renderAll();
  log(`Marked LOSS (actual ${actual}) — consecutiveLosses=${consecutiveLosses}`);
  // if consecutiveLosses >=2 and beast enabled -> next prediction will be adjusted
};

document.getElementById('exportBtn').onclick = ()=>{
  const data = {lastResults, timestamp: Date.now()};
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'wingo_history.json'; a.click();
  URL.revokeObjectURL(url);
};

// chart
function renderChart(){
  const freqBig = lastResults.filter(x=>x==='BIG').length;
  const freqSmall = lastResults.filter(x=>x==='SMALL').length;
  const labels = ['BIG','SMALL'];
  const data = [freqBig, freqSmall];
  const ctx = document.getElementById('freqChart').getContext('2d');
  if(chart) chart.destroy();
  chart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Frequency',
        data,
        backgroundColor: ['rgba(0,210,168,0.85)', 'rgba(255,181,105,0.95)'],
        borderRadius: 8
      }]
    },
    options:{
      plugins:{legend:{display:false}},
      scales:{y:{beginAtZero:true, ticks:{color:'#9fb0d6'}}, x:{ticks:{color:'#9fb0d6'}}}
    }
  });
}

// initialize elements and events
function renderAll(){
  lastResults = readLast();
  renderLastList();
  renderHistory();
  renderChart();
}
renderAll();

// allow clicking chips to remove/ toggle above handled
document.getElementById('periodInput').addEventListener('keypress', (e)=>{ if(e.key === 'Enter') { /* nothing */ } });

// persist threshold changes
thresholdInput.addEventListener('change', ()=> {
  let v = parseFloat(thresholdInput.value);
  if(isNaN(v) || v<=0 || v>=1) { thresholdInput.value = '0.75'; alert('Enter threshold between 0.5 and 0.95'); }
});

</script>
</body>
</html>
