<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mr Perfect Pro - Big/Small Prediction</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { background: linear-gradient(to bottom right, #1f1c2c, #928dab); font-family: 'Segoe UI', sans-serif; }
    .hidden { display: none; }
    .popup { position: fixed; top: 30%; left: 50%; transform: translate(-50%, -50%); background: #222; color: white; padding: 20px; border-radius: 10px; z-index: 999; text-align: center; }
  </style>
</head>
<body class="text-white p-6">
  <div id="mainApp">
    <h1 class="text-3xl font-bold text-center text-purple-400 mb-6">ðŸŽ¯ Mr Perfect Pro - Big/Small Prediction</h1>

    <div class="max-w-4xl mx-auto">
      <h2 class="text-xl font-bold mb-4">ðŸ”¢ Enter Last 10 Results (Big or Small)</h2>
      <div class="grid grid-cols-2 md:grid-cols-5 gap-3 mb-6" id="inputFields"></div>
      <button id="predictBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded w-full">Predict</button>
      <div id="predictionResult" class="mt-4 text-center text-2xl"></div>
      <div id="logicBreakdown" class="grid grid-cols-2 md:grid-cols-5 gap-3 mt-6"></div>
    </div>

    <div class="max-w-4xl mx-auto mt-10">
      <canvas id="predictionChart" height="150"></canvas>
    </div>
  </div>

  <div id="popup" class="popup hidden">
    <p id="popupMsg"></p>
    <button onclick="closePopup()" class="mt-4 px-4 py-2 bg-green-500 rounded">OK</button>
  </div>

  <audio id="dingSound" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>

  <script>
    const logicNames = ["Trend", "Pattern", "Reverse", "Mirror", "Skip", "Weighted", "Zigzag", "Repeat", "Majority", "Gap"];
    const inputFields = document.getElementById("inputFields");
    const predictionResult = document.getElementById("predictionResult");
    const logicBreakdown = document.getElementById("logicBreakdown");
    const predictBtn = document.getElementById("predictBtn");
    const ding = document.getElementById("dingSound");
    const popup = document.getElementById("popup");
    const popupMsg = document.getElementById("popupMsg");
    const chartCanvas = document.getElementById("predictionChart");

    let historyData = [];
    let lastPrediction = null;
    let predictionLocked = false;
    let logicVotes = [];

    for (let i = 0; i < 10; i++) {
      const select = document.createElement("select");
      select.className = "bg-gray-800 border border-purple-500 p-2 rounded text-center text-white";
      select.innerHTML = `<option value="">--</option><option value="Big">Big</option><option value="Small">Small</option>`;
      inputFields.appendChild(select);
    }

    function analyzeLogic(type, values) {
      switch (type) {
        case "Trend":
          return values.filter(v => v === values[values.length - 1]).length > 5 ? values[values.length - 1] : (values[9] === "Big" ? "Small" : "Big");
        case "Pattern":
          return values[0] === values[2] && values[2] === values[4] ? values[0] : values[9] === "Big" ? "Small" : "Big";
        case "Reverse":
          return values[9] === "Big" ? "Small" : "Big";
        case "Mirror":
          return values[8] === values[6] ? values[8] : values[9];
        case "Skip":
          return values[8] === values[6] && values[6] === values[4] ? values[8] : values[9];
        case "Weighted":
          let count = values.reduce((acc, cur) => { acc[cur] = (acc[cur] || 0) + 1; return acc; }, {});
          return count["Big"] >= count["Small"] ? "Big" : "Small";
        case "Zigzag":
          return values[9] === values[7] ? values[9] : values[9] === "Big" ? "Small" : "Big";
        case "Repeat":
          return values[9];
        case "Majority":
          let countMajor = values.reduce((acc, cur) => { acc[cur] = (acc[cur] || 0) + 1; return acc; }, {});
          return countMajor["Big"] > countMajor["Small"] ? "Big" : "Small";
        case "Gap":
          return values[0] === values[3] ? values[0] : values[9] === "Big" ? "Small" : "Big";
        default:
          return "Big";
      }
    }

    function predict() {
      if (predictionLocked) {
        alert("You must confirm the last result before predicting again.");
        return;
      }

      const inputs = Array.from(inputFields.querySelectorAll("select"));
      const values = inputs.map(s => s.value).filter(v => v);
      if (values.length < 10) return alert("Enter all 10 values (Big/Small)");

      logicVotes = logicNames.map(name => analyzeLogic(name, values));
      logicBreakdown.innerHTML = logicVotes.map((vote, i) =>
        `<div class='p-2 bg-gray-800 rounded text-center'><strong>${logicNames[i]}</strong><div class='text-${vote === "Big" ? "green" : "red"}-400'>${vote}</div></div>`
      ).join("");

      const count = logicVotes.reduce((acc, cur) => { acc[cur] = (acc[cur] || 0) + 1; return acc; }, {});
      const final = count["Big"] > count["Small"] ? "Big" : "Small";
      const confidence = Math.floor((count[final] / 10) * 100);

      predictionResult.innerHTML = `Prediction: <span class='text-${final === "Big" ? "green" : "red"}-400 font-bold'>${final}</span> (${confidence}%)`;
      ding.play();

      lastPrediction = final;
      predictionLocked = true;
      showResultPopup();
    }

    function showResultPopup() {
      const win = confirm("Did your prediction win? Click OK for Win, Cancel for Loss.");
      if (win) {
        popupMsg.innerText = "âœ… You Won! Prediction successful.";
      } else {
        popupMsg.innerText = "âŒ You Lost! Improving next logic...";
        improveNextLogic();
      }
      popup.classList.remove("hidden");
      historyData.push({ index: historyData.length + 1, confidence: 10 * logicVotes.filter(v => v === lastPrediction).length });
      drawChart();
    }

    function closePopup() {
      popup.classList.add("hidden");
      predictionLocked = false;
    }

    function improveNextLogic() {
      logicNames.push("SmartAI" + Math.floor(Math.random() * 1000));
    }

    function drawChart() {
      new Chart(chartCanvas, {
        type: 'line',
        data: {
          labels: historyData.map(h => h.index),
          datasets: [{
            label: 'Confidence %',
            data: historyData.map(h => h.confidence),
            borderColor: '#a78bfa',
            backgroundColor: 'rgba(167, 139, 250, 0.2)',
            tension: 0.3,
          }]
        },
        options: {
          responsive: true,
          scales: {
            y: { min: 0, max: 100, ticks: { color: 'white' } },
            x: { ticks: { color: 'white' } }
          },
          plugins: { legend: { labels: { color: 'white' } } }
        }
      });
    }

    predictBtn.addEventListener("click", predict);
  </script>
</body>
</html>
